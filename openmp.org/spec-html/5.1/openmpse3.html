<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-5385519-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-5385519-3');
</script><title>Execution Model</title> 
<meta  charset="iso-8859-1" /> 
<meta name="generator" content="TeX4ht (http://www.tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="openmp.css" /> 
<meta name="src" content="openmp.tex" /> 
</head><body 
>
<div class="page-heading-wrapper"><div class="page-heading-home"><a href="./openmp.html">HOME</a></div><div class="page-heading"> | <strong>OPENMP API Specification: Version 5.1 November 2020</strong></div></div> <!--l. 3--><div class="crosslinks"><p class="noindent">[<a 
href="openmpse4.html" >next</a>] [<a 
href="openmpsu8.html" >prev</a>] [<a 
href="openmpsu8.html#tailopenmpsu8.html" >prev-tail</a>] [<a 
href="#tailopenmpse3.html">tail</a>] [<a 
href="openmpch1.html#openmpse3.html" >up</a>] </p></div>
<h3 class="sectionHead"><span class="titlemark">1.3</span>&#x00A0;&#x00A0;<a 
 id="x16-150001.3"></a>Execution Model</h3>
<a 
 id="dx16-15001"></a>
<p>The OpenMP API uses the fork-join model of parallel execution. Multiple threads of execution perform
tasks defined implicitly or explicitly by OpenMP directives. The OpenMP API is intended to support
programs that will execute correctly both as parallel programs (multiple threads of execution and a full
OpenMP support library) and as sequential programs (directives ignored and a simple OpenMP stubs
library). However, a conforming OpenMP program may execute correctly as a parallel program but not as a
sequential program, or may produce different results when executed as a parallel program compared to
when it is executed as a sequential program. Further, using different numbers of threads may
result in different numeric results because of changes in the association of numeric operations.
For example, a serial addition reduction may have a different pattern of addition associations
than a parallel reduction. These different associations may change the results of floating-point
addition.
</p> 
<p>An OpenMP program begins as a single thread of execution, called an initial thread. An initial
thread executes sequentially, as if the code encountered is part of an implicit task region, called
an initial task region, that is generated by the implicit parallel region surrounding the whole
program.
</p> 
<p>The thread that executes the implicit parallel region that surrounds the whole program executes on the <span class="emph">host
device</span>. An implementation may support other devices besides the host device. If supported, these devices
are available to the host device for <span class="emph">offloading</span> code and data. Each device has its own threads that are distinct
from threads that execute on another device. Threads cannot migrate from one device to another
device. Each device is identified by a device number. The device number for the host device is
the value of the total number of non-host devices, while each non-host device has a unique
device number that is greater than or equal to zero and less than the device number for the host
device.
                                                                            
                                                                            
</p> 
<p>When a <span class="textbf"><span class="texttt">target</span></span> construct is encountered, a new <span class="emph">target task</span> is generated. The <span class="emph">target task</span> region encloses
the <span class="textbf"><span class="texttt">target</span></span> region. The <span class="emph">target task</span> is complete after the execution of the <span class="textbf"><span class="texttt">target</span></span> region is
complete.
</p> 
<p>When a <span class="emph">target task</span> executes, the enclosed <span class="textbf"><span class="texttt">target</span></span> region is executed by an initial thread. The initial thread
executes sequentially, as if the target region is part of an initial task region that is generated by an implicit
parallel region. The initial thread may execute on the requested <span class="emph">target device</span>, if it is available and supported.
If the target device does not exist or the implementation does not support it, all <span class="textbf"><span class="texttt">target</span></span> regions associated
with that device execute on the host device.
</p> 
<p>The implementation must ensure that the <span class="textbf"><span class="texttt">target</span></span> region executes as if it were executed in the data
environment of the target device unless an <span class="textbf"><span class="texttt">if</span></span> clause is present and the <span class="textbf"><span class="texttt">if</span></span> clause expression evaluates to
<span class="textit"><span class="textrm">false</span></span>.
</p> 
<p>The <span class="textbf"><span class="texttt">teams</span></span> construct creates a <span class="emph">league of teams</span>, where each team is an initial team that comprises an initial
thread that executes the <span class="textbf"><span class="texttt">teams</span></span> region. Each initial thread executes sequentially, as if the code encountered
is part of an initial task region that is generated by an implicit parallel region associated with each
team. Whether the initial threads concurrently execute the <span class="textbf"><span class="texttt">teams</span></span> region is unspecified, and
a program that relies on their concurrent execution for the purposes of synchronization may
deadlock.
</p> 
<p>If a construct creates a data environment, the data environment is created at the time the construct is
encountered. The description of a construct defines whether it creates a data environment.
</p> 
<p>When any thread encounters a <span class="textbf"><span class="texttt">parallel</span></span> construct, the thread creates a team of itself and zero or more
additional threads and becomes the primary thread of the new team. A set of implicit tasks, one per thread,
is generated. The code for each task is defined by the code inside the <span class="textbf"><span class="texttt">parallel</span></span> construct. Each task is
assigned to a different thread in the team and becomes tied; that is, it is always executed by the thread to
which it is initially assigned. The task region of the task being executed by the encountering thread is
suspended, and each member of the new team executes its implicit task. An implicit barrier occurs at the
end of the <span class="textbf"><span class="texttt">parallel</span></span> region. Only the primary thread resumes execution beyond the end of
the <span class="textbf"><span class="texttt">parallel</span></span> construct, resuming the task region that was suspended upon encountering
the <span class="textbf"><span class="texttt">parallel</span></span> construct. Any number of <span class="textbf"><span class="texttt">parallel</span></span> constructs can be specified in a single
program.
</p> 
<p><span class="textbf"><span class="texttt">parallel</span></span> regions may be arbitrarily nested inside each other. If nested parallelism is disabled, or is not
supported by the OpenMP implementation, then the new team that is created by a thread that encounters a
<span class="textbf"><span class="texttt">parallel</span></span> construct inside a <span class="textbf"><span class="texttt">parallel</span></span> region will consist only of the encountering thread. However, if
nested parallelism is supported and enabled, then the new team can consist of more than one thread. A
<span class="textbf"><span class="texttt">parallel</span></span> construct may include a <span class="textbf"><span class="texttt">proc_bind</span></span> clause to specify the places to use for the threads in the
team within the <span class="textbf"><span class="texttt">parallel</span></span> region.
</p> 
<p>When any team encounters a worksharing construct, the work inside the construct is divided among the
members of the team, and executed cooperatively instead of being executed by every thread. An implicit
barrier occurs at the end of any region that corresponds to a worksharing construct for which the <span class="textbf"><span class="texttt">nowait</span></span>
clause is not specified. Redundant execution of code by every thread in the team resumes after the end of the
worksharing construct.
                                                                            
                                                                            
</p> 
<p>When any thread encounters a <span class="emph">task generating construct</span>, one or more explicit tasks are generated.
Execution of explicitly generated tasks is assigned to one of the threads in the current team,
subject to the thread&#8217;s availability to execute work. Thus, execution of the new task could be
immediate, or deferred until later according to task scheduling constraints and thread availability.
Threads are allowed to suspend the current task region at a task scheduling point in order to
execute a different task. If the suspended task region is for a tied task, the initially assigned thread
later resumes execution of the suspended task region. If the suspended task region is for an
untied task, then any thread may resume its execution. Completion of all explicit tasks bound to
a given parallel region is guaranteed before the primary thread leaves the implicit barrier at
the end of the region. Completion of a subset of all explicit tasks bound to a given parallel
region may be specified through the use of task synchronization constructs. Completion of
all explicit tasks bound to the implicit parallel region is guaranteed by the time the program
exits.
</p> 
<p>When any thread encounters a <span class="textbf"><span class="texttt">simd</span></span> construct, the iterations of the loop associated with the construct may
be executed concurrently using the SIMD lanes that are available to the thread.
</p> 
<p>When a <span class="textbf"><span class="texttt">loop</span></span> construct is encountered, the iterations of the loop associated with the construct are executed
in the context of its encountering threads, as determined according to its binding region. If the <span class="textbf"><span class="texttt">loop</span></span> region
binds to a <span class="textbf"><span class="texttt">teams</span></span> region, the region is encountered by the set of primary threads that execute the <span class="textbf"><span class="texttt">teams</span></span>
region. If the <span class="textbf"><span class="texttt">loop</span></span> region binds to a <span class="textbf"><span class="texttt">parallel</span></span> region, the region is encountered by the team of
threads that execute the <span class="textbf"><span class="texttt">parallel</span></span> region. Otherwise, the region is encountered by a single
thread.
</p> 
<p>If the <span class="textbf"><span class="texttt">loop</span></span> region binds to a <span class="textbf"><span class="texttt">teams</span></span> region, the encountering threads may continue execution after the
<span class="textbf"><span class="texttt">loop</span></span> region without waiting for all iterations to complete; the iterations are guaranteed to complete before
the end of the <span class="textbf"><span class="texttt">teams</span></span> region. Otherwise, all iterations must complete before the encountering threads
continue execution after the <span class="textbf"><span class="texttt">loop</span></span> region. All threads that encounter the <span class="textbf"><span class="texttt">loop</span></span> construct may
participate in the execution of the iterations. Only one of these threads may execute any given
iteration.
</p> 
<p>The <span class="textbf"><span class="texttt">cancel</span></span> construct can alter the previously described flow of execution in an OpenMP region. The
effect of the <span class="textbf"><span class="texttt">cancel</span></span> construct depends on its <span class="textit"><span class="textrm">construct-type-clause</span></span>. If a task encounters a <span class="textbf"><span class="texttt">cancel</span></span>
construct with a <span class="textbf"><span class="texttt">taskgroup</span></span><span class="textit"><span class="textrm">construct-type-clause</span></span>, then the task activates cancellation and continues
execution at the end of its <span class="textbf"><span class="texttt">task</span></span> region, which implies completion of that task. Any other task in that
<span class="textbf"><span class="texttt">taskgroup</span></span> that has begun executing completes execution unless it encounters a <span class="textbf"><span class="texttt">cancellation</span></span>
<span class="textbf"><span class="texttt">point</span></span> construct, in which case it continues execution at the end of its <span class="textbf"><span class="texttt">task</span></span> region, which implies its
completion. Other tasks in that <span class="textbf"><span class="texttt">taskgroup</span></span> region that have not begun execution are aborted, which
implies their completion.
</p> 
<p>For all other <span class="textit"><span class="textrm">construct-type-clause</span></span> values, if a thread encounters a <span class="textbf"><span class="texttt">cancel</span></span> construct, it activates
cancellation of the innermost enclosing region of the type specified and the thread continues execution at the
end of that region. Threads check if cancellation has been activated for their region at cancellation points
and, if so, also resume execution at the end of the canceled region.
</p> 
<p>If cancellation has been activated, regardless of <span class="textit"><span class="textrm">construct-type-clause</span></span>, threads that are waiting inside a
                                                                            
                                                                            
barrier other than an implicit barrier at the end of the canceled region exit the barrier and resume
execution at the end of the canceled region. This action can occur before the other threads reach that
barrier.
</p> 
<p>Synchronization constructs and library routines are available in the OpenMP API to coordinate tasks and
data access in <span class="textbf"><span class="texttt">parallel</span></span> regions. In addition, library routines and environment variables are available to
control or to query the runtime environment of OpenMP programs.
</p> 
<p>The OpenMP specification makes no guarantee that input or output to the same file is synchronous when
executed in parallel. In this case, the programmer is responsible for synchronizing input and output
processing with the assistance of OpenMP synchronization constructs or library routines. For the
case where each thread accesses a different file, the programmer does not need to synchronize
access.
</p> 
<p>All concurrency semantics defined by the base language with respect to threads of execution apply to
OpenMP threads, unless specified otherwise.
</p> 
<!--l. 45--><div class="crosslinks"><p class="noindent">[<a 
href="openmpse4.html" >next</a>] [<a 
href="openmpsu8.html" >prev</a>] [<a 
href="openmpsu8.html#tailopenmpsu8.html" >prev-tail</a>] [<a 
href="openmpse3.html" >front</a>] [<a 
href="openmpch1.html#openmpse3.html" >up</a>] </p></div>
<p><a 
 id="tailopenmpse3.html"></a> </p> 
 
</body> 
</html>